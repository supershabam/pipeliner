package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"text/template"
)

var (
	operator = flag.String("operator", "", "operator to generate (batch, flatMap)")
	fn       = flag.String("func", "", "func name to generate")
	from     = flag.String("from", "", "from this type")
	into     = flag.String("into", "", "into this type")
	file     = flag.String("file", "", "output file to write")
)

type pipelineConfig struct {
	Package string
	Version string
	Fn      string
	From    string
	Into    string
}

const batch = `// AUTOMATICALLY GENERATED FILE - DO NOT EDIT
// generated by pipeliner@v{{.Version}}
package {{.Package}}

// {{.Fn}} is a generated implementation of the batch operator
func {{.Fn}}(ctx pipeliner.Context, max int, in <-chan {{.From}}) <-chan []{{.From}} {
	done := ctx.Done()
	if max <= 0 {
		panic("batch max must be greater than zero")
	}
	out := make(chan []{{.From}})
	go func() {
		defer close(out)
	Start:
		batch := []{{.From}}{}
		for {
			if len(batch) >= max {
				select {
				case <-done:
					return
				case out <- batch:
				}
				goto Start
			}
			item, active := <-in
			if !active {
				if len(batch) > 0 {
					select {
					case <-done:
						return
					case out <- batch:
					}
				}
				return
			}
			batch = append(batch, item)
		}
	}()
	return out
}`

const flatMap = `// AUTOMATICALLY GENERATED FILE - DO NOT EDIT
// generated by pipeliner@v{{.Version}}
package {{.Package}}

// {{.Fn}} is a generated implementation of the flatMap operator
func {{.Fn}}(ctx pipeliner.Context, concurrency int, in <-chan {{.From}}, fn func(pipeliner.Context, {{.From}}) <-chan {{.Into}}) <-chan {{.Into}} {
	done := ctx.Done()
	out := make(chan {{.Into}})
	go func() {
		defer close(out)
		wg := sync.WaitGroup{}
		wg.Add(concurrency)
		for i := 0; i < concurrency; i++ {
			go func() {
				defer wg.Done()
				for v := range in {
					for w := range fn(ctx, v) {
						select {
						case <-done:
							return
						case out <- w:
						}
					}
				}
			}()
		}
		wg.Wait()
	}()
	return out
}
`

const fromOperator = `// AUTOMATICALLY GENERATED FILE - DO NOT EDIT
// generated by pipeliner@v{{.Version}}
package {{.Package}}

// {{.Fn}} is a generated implementation of the from operator
func {{.Fn}}(ctx pipeliner.Context, in []{{.From}}) <-chan {{.From}} {
	done := ctx.Done()
	out := make(chan {{.From}})
	go func() {
		defer close(out)
		for _, v := range in {
			select {
			case <-done:
				return
			case out <- v:
			}
		}
	}()
	return out
}
`

func usage() {
	fmt.Fprintf(os.Stderr, "usage: pipeliner\n")
	flag.PrintDefaults()
	os.Exit(2)
}

func write(config pipelineConfig, source, file string) error {
	out, err := os.Create(file)
	if err != nil {
		return err
	}
	tmpl, err := template.New("pipeliner").Parse(source)
	if err != nil {
		return err
	}
	err = tmpl.Execute(out, config)
	if err != nil {
		return err
	}
	err = out.Close()
	if err != nil {
		return err
	}
	return exec.Command("goimports", "-w", file).Run()
}

func main() {
	flag.Parse()
	// TODO: validate inputs
	config := pipelineConfig{
		Package: os.Getenv("GOPACKAGE"),
		Version: "0.1.1",
		Fn:      *fn,
		From:    *from,
		Into:    *into,
	}

	var err error
	switch *operator {
	case "batch":
		err = write(config, batch, *file)
	case "flatMap":
		err = write(config, flatMap, *file)
	case "from":
		err = write(config, fromOperator, *file)
	default:
		usage()
	}
	if err != nil {
		log.Fatal(err)
	}
}
